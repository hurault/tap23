open Dataset

(* copy / paste classif.mli generated by coq*)
module type Classif = sig
  type bool = True | False
  type nat = O | S of nat
  type ('a, 'b) prod = Pair of 'a * 'b
  type 'a list = Nil | Cons of 'a * 'a list

  val app : 'a1 list -> 'a1 list -> 'a1 list
  val sub : nat -> nat -> nat
  val nb_feature : nat

  type t (* AXIOM TO BE REALIZED *)

  type tk (* AXIOM TO BE REALIZED *)

  val tk_eq_dec : tk -> tk -> bool
  val nu : nat -> t
  val lambda : nat -> t
  val freeAttr_aux : nat -> nat -> t list -> t list -> (t list, t list) prod
  val freeAttr : nat -> t list -> t list -> (t list, t list) prod
  val fixAttr_aux : nat -> t list -> t list -> t list -> (t list, t list) prod

  val fixAttr :
    nat ->
    t list ->
    t list ->
    t list ->
    nat list ->
    ((t list, t list) prod, nat list) prod

  val findAXp_aux_j :
    (t list -> tk) -> nat -> t list -> t list -> t list -> nat list -> nat list

  val findAXp_aux :
    (t list -> tk) -> nat -> t list -> t list -> t list -> nat list -> nat list

  val findAXp : (t list -> tk) -> t list -> nat list

  val findCXp_aux_j :
    (t list -> tk) -> nat -> t list -> t list -> t list -> nat list -> nat list

  val findCXp_aux :
    (t list -> tk) -> nat -> t list -> t list -> t list -> nat list -> nat list

  val feature_f : nat -> (nat -> t) -> t list
  val findCXp : (t list -> tk) -> t list -> nat list

  (* Added - not generated *)
  val findAXp_friendly : (t list -> tk) -> t List.t -> int List.t
  val findCXp_friendly : (t list -> tk) -> t List.t -> int List.t
  val from_list : 'a list -> 'a List.t
end

module AxpCxp (D : Dataset) : Classif with type t = D.t and type tk = D.tk =
struct
  (* Generated *)

  type bool = True | False
  type nat = O | S of nat
  type ('a, 'b) prod = Pair of 'a * 'b
  type 'a list = Nil | Cons of 'a * 'a list

  (* Data convertion : added*)
  let rec int_to_nat n = if n = 0 then O else S (int_to_nat (n - 1))
  let rec nat_to_int n = match n with O -> 0 | S m -> nat_to_int m + 1
  let rec to_list l = match l with [] -> Nil | t :: q -> Cons (t, to_list q)

  let rec from_list l =
    match l with Nil -> [] | Cons (t, q) -> t :: from_list q

  (** val app : 'a1 list -> 'a1 list -> 'a1 list **)

  let rec app l m = match l with Nil -> m | Cons (a, l1) -> Cons (a, app l1 m)

  (** val sub : nat -> nat -> nat **)

  let rec sub n m =
    match n with O -> n | S k -> ( match m with O -> n | S l -> sub k l)

  (** val nb_feature : nat **)
  let nb_feature = int_to_nat D.nb_feature

  type t = D.t
  type tk = D.tk

  (** val tk_eq_dec : t -> t -> bool **)

  let tk_eq_dec f1 f2 = if D.tk_eq_dec f1 f2 then True else False

  (** val nu : nat -> t **)

  let nu n = D.nu (nat_to_int n)

  (** val lambda : nat -> t **)

  let lambda n = D.lambda (nat_to_int n)

  (** val freeAttr_aux :
    nat -> nat -> t list -> t list -> (t list, t list) prod **)

  let rec freeAttr_aux i n vl vu =
    match i with
    | O -> (
        match vl with
        | Nil -> Pair (vl, vu)
        | Cons (_, ql) -> (
            match vu with
            | Nil -> Pair (vl, vu)
            | Cons (_, qu) -> Pair (Cons (lambda n, ql), Cons (nu n, qu))))
    | S _ -> (
        match vl with
        | Nil -> Pair (vl, vu)
        | Cons (tl, ql) -> (
            match vu with
            | Nil -> Pair (vl, vu)
            | Cons (tu, qu) ->
                let (Pair (rl, ru)) = freeAttr_aux (sub i (S O)) n ql qu in
                Pair (Cons (tl, rl), Cons (tu, ru))))

  (** val freeAttr :
        nat -> t list -> t list -> (t list, t list) prod **)

  let freeAttr i vl vu = freeAttr_aux i i vl vu

  (** val fixAttr_aux :
        nat -> t list -> t list -> t list -> (t list, t list) prod **)

  let rec fixAttr_aux i v vl vu =
    match i with
    | O -> (
        match v with
        | Nil -> Pair (vl, vu)
        | Cons (v0, _) -> (
            match vl with
            | Nil -> Pair (vl, vu)
            | Cons (_, qvl) -> (
                match vu with
                | Nil -> Pair (vl, vu)
                | Cons (_, qvu) -> Pair (Cons (v0, qvl), Cons (v0, qvu)))))
    | S _ -> (
        match v with
        | Nil -> Pair (vl, vu)
        | Cons (_, qv) -> (
            match vl with
            | Nil -> Pair (vl, vu)
            | Cons (vl0, qvl) -> (
                match vu with
                | Nil -> Pair (vl, vu)
                | Cons (vu0, qvu) ->
                    let (Pair (nvl, nvu)) =
                      fixAttr_aux (sub i (S O)) qv qvl qvu
                    in
                    Pair (Cons (vl0, nvl), Cons (vu0, nvu)))))

  (** val fixAttr :
        nat -> t list -> t list -> t list -> nat list -> ((t list, t
        list) prod, nat list) prod **)

  let fixAttr i v vl vu p = Pair (fixAttr_aux i v vl vu, Cons (i, p))

  (** val findAXp_aux_j :
        (t list -> tk) -> nat -> t list -> t list -> t list -> nat list
        -> nat list **)

  let rec findAXp_aux_j k j v vl vu p =
    match j with
    | O -> p
    | S jmoins1 -> (
        let (Pair (nvl, nvu)) = freeAttr (sub nb_feature j) vl vu in
        match tk_eq_dec (k nvl) (k nvu) with
        | True -> findAXp_aux_j k jmoins1 v nvl nvu p
        | False ->
            let (Pair (p0, np)) = fixAttr (sub nb_feature j) v nvl nvu p in
            let (Pair (nvl0, nvu0)) = p0 in
            findAXp_aux_j k jmoins1 v nvl0 nvu0 np)

  (** val findAXp_aux :
        (t list -> tk) -> nat -> t list -> t list -> t list -> nat list
        -> nat list **)

  let findAXp_aux k i v vl vu p = findAXp_aux_j k (sub nb_feature i) v vl vu p

  (** val findAXp : (t list -> tk) -> t list -> nat list **)

  let findAXp k v = findAXp_aux k O v v v Nil

  (** val findCXp_aux_j :
        (t list -> tk) -> nat -> t list -> t list -> t list -> nat list
        -> nat list **)

  let rec findCXp_aux_j k j v vl vu p =
    match j with
    | O -> p
    | S jmoins1 -> (
        let (Pair (p0, np)) = fixAttr (sub nb_feature j) v vl vu p in
        let (Pair (nvl, nvu)) = p0 in
        match tk_eq_dec (k nvl) (k nvu) with
        | True ->
            let (Pair (nvl0, nvu0)) = freeAttr (sub nb_feature j) nvl nvu in
            findCXp_aux_j k jmoins1 v nvl0 nvu0 np
        | False -> findCXp_aux_j k jmoins1 v nvl nvu p)

  (** val findCXp_aux :
        (t list -> tk) -> nat -> t list -> t list -> t list -> nat list
        -> nat list **)

  let findCXp_aux k i v vl vu p = findCXp_aux_j k (sub nb_feature i) v vl vu p

  (** val feature_f : nat -> (nat -> t) -> t list **)

  let rec feature_f s f =
    match s with
    | O -> Nil
    | S smoins1 -> app (feature_f smoins1 f) (Cons (f smoins1, Nil))

  (** val findCXp : (t list -> tk) -> t list -> nat list **)

  let findCXp k v =
    findCXp_aux k O v
      (feature_f nb_feature lambda)
      (feature_f nb_feature nu) Nil

  (* Added *)
  let findAXp_friendly k v =
    List.map nat_to_int (from_list (findAXp k (to_list v)))

  let findCXp_friendly k v =
    List.map nat_to_int (from_list (findCXp k (to_list v)))
end
